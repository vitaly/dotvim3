
" src/plugins/20-settings/files/vimrc.after -------------------

" make Y consistent with C and D
" must be in 'after' to prevent yankring overriding it
nnoremap Y y$

" src/plugins/20-settings/plugins/keymap/files/vimrc.after -------------------

set timeoutlen=1000

" src/plugins/20-settings/plugins/keymap/engine/which_key/files/vimrc.after -------------------

let g:WhichKeyFormatFunc = function('my#keymap#format')

augroup RegisterKeyMap
  autocmd!
  autocmd   User    vim-which-key     call which_key#register(' ', 'g:my#keymap#leader#map')
  autocmd   User    vim-which-key     call which_key#register(',', 'g:my#keymap#localleader#map')
augroup END

nnoremap <silent> <leader>      :WhichKey       ' '<CR>
nnoremap <silent> <localleader> :WhichKey       ','<CR>

xnoremap <silent> <leader>      :<c-u>WhichKeyVisual ' '<CR>
xnoremap <silent> <localleader> :<c-u>WhichKeyVisual ','<CR>

map                             <plug>(Search/Keys)       :<c-u>WhichKey       ''
nmap <leader>sw                 <plug>(Search/Keys)

let g:which_key_sep = "|"

" src/plugins/40-ide/plugins/10-completion/engine/coc/files/vimrc.after -------------------

" hi CocHighlightText cterm=underline gui=underline
hi CocHighlightText cterm=inverse gui=inverse

let g:hover_on_hold = get(g:, "hover_on_hold", 1)
fun! MyHoverActions()
  if g:hover_on_hold
    call CocActionAsync('highlight')
  endif
endf

fun! MyClickActions()
  call CocActionAsync('highlight')
endfun

fun! MyMClickActions()
  if CocAction('ensureDocument')
    call CocActionAsync('doHover')
  end
endfun

nnoremap <silent><LeftMouse> :call MyClickActions()<CR><LeftMouse>
nnoremap <silent><M-LeftMouse> :call MyMClickActions()<CR><M-LeftMouse>

augroup HoldHoverActions
  au!
  au CursorHold * silent call MyHoverActions()
  au User CocJumpPlaceholder call CocActionAsync('showSignatureHelp')
augroup END

fu! s:toggle_hover_on_hold()
  let g:hover_on_hold = ! g:hover_on_hold
  echo g:hover_on_hold
endfu

noremap                     <plug>(Toggle/Hover-On-Hold) :call <SID>s:toggle_hover_on_hold()<cr>
nmap    <silent> <leader>Th <plug>(Toggle/Hover-On-Hold)

" src/plugins/40-ide/plugins/50-gutentags/files/vimrc.after -------------------

call add(g:gutentags_project_info, {'type': 'javascript', 'file': 'package.json'})

let g:gutentags_file_list_command = {
   \ 'markers': {
      \ '.git': 'git ls-files',
      \ '.hg': 'hg files',
      \ },
   \ }

" function to dump all gutentags variables
fu! s:gutentag_dump() abort
  for l:v in sort(filter(keys(g:), 'v:val =~ "gutentags"'))
    echon 'g:' . l:v . ' = '
    echon get(g:, l:v)
    echo ''
  endfor

  for l:v in sort(filter(keys(b:), 'v:val =~ "gutentags"'))
    echon 'b:' . l:v . ' = '
    echon get(b:, l:v)
    echo ''
  endfor
endfu
command! GutentagDump call s:gutentag_dump()

call my#keymap#leader('ag', '+Gutentags')

nnoremap  <leader>agd       :GutentagDump<cr>

" src/plugins/50-fuzzy-tools/plugins/00-unite/files/vimrc.after -------------------

call unite#filters#matcher_default#use(['matcher_fuzzy'])

" src/plugins/99-final/plugins/10-local-configs/files/vimrc.after -------------------

source ~/.vim/local/vimrc.after

" local/plugins/fileinfotoggle/vimrc.after -------------------

" disable intro message
set shortmess+=I
" enable fileinfo
set shortmess-=F
" echom &shortmess

fu! s:toggleFileinfoMessages()
  if &shortmess =~# 'F'
    set shortmess-=F
    echo 'fileinfo messages enabled'
  else
    set shortmess+=F
    echo 'fileinfo messages disabled'
  endif
endfu

call my#keymap#leader('Tf', '+File')
noremap                <plug>(Toggle/Fileinfo-Messages)   :<C-U>call <SID>toggleFileinfoMessages()<CR>
nmap      <leader>Tfi  <plug>(Toggle/Fileinfo-Messages)
