scriptencoding utf8



fu! SetupMyMacros()
  echom " @s - enclose selection in double * (bold in markdown)"
  let @s="S*gvS*"

  echom " @p - format paragraph"
  let @p="V}kQ"

  echom " @u - surround current letter with [] and upcase it, e.g. foo -> [F]oo"
  let @u="vS]v%U"

  echom " @l - adds line of ------ up to column 80 at the end of the current line"
  let @l="$2lv079lr-"
endfu








" let g:lightline.colorscheme = 'molokai'
" let g:lightline.colorscheme = 'hypsteria_alter'

" call lightline#init()
" call lightline#colorscheme()
" call lightline#update()
"
" call LightlineColorscheme('wombat')
" call LightlineColorscheme('solarized')
" call LightlineColorscheme('powerline')
" call LightlineColorscheme('jellybeans')
" call LightlineColorscheme('Tomorrow')
" call LightlineColorscheme('Tomorrow_Night')
" call LightlineColorscheme('Tomorrow_Night_Blue')
" call LightlineColorscheme('Tomorrow_Night_Eighties')
" call LightlineColorscheme('PaperColor')
" call LightlineColorscheme('seoul256')
" call LightlineColorscheme('landscape')
" call LightlineColorscheme('one')
" call LightlineColorscheme('darcula')
" call LightlineColorscheme('molokai')
" call LightlineColorscheme('materia')
" call LightlineColorscheme('material')
" call LightlineColorscheme('OldHope')
" call LightlineColorscheme('nord')
" call LightlineColorscheme('16color')
" call LightlineColorscheme('deus')

" call LightlineColorscheme('molokai')
" call LightlineColorscheme('hypsteria_alter')
" call LightlineColorscheme('neodark_alter')













set eol
set nobinary
" set t_Co=256
" set t_AB=^[[48;5;%dm
" set t_AF=^[[38;5;%dm
" set notermguicolors

set cursorline
set cursorcolumn

set foldcolumn=2

" set relativenumber!

" inoremap kj <esc>l

" highlight helper

fu! ShowHighlight()
  echo "hi<" . synIDattr(synID(line("."),col("."),1),"name") . '> trans<' . synIDattr(synID(line("."),col("."),0),"name") . "> lo<" . synIDattr(synIDtrans(synID(line("."),col("."),1)),"name") . ">"
endfu
map ,L :call ShowHighlight()<cr>
command! HI call ShowHighlight()

set modeline

" to use :Run command    - will pipe to quickfix window
" command -nargs=+ Run :cexpr system('<args>') | copen


""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
""""""""""""""""""""""""""" COLORS """""""""""""""""""""""""""""""""
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""






" if exists('$TMUX')
"   let &t_SI = "\<Esc>Ptmux;\<Esc>\<Esc>]50;CursorShape=1\x7\<Esc>\\"
"   let &t_EI = "\<Esc>Ptmux;\<Esc>\<Esc>]50;CursorShape=0\x7\<Esc>\\"
" else
"   let &t_SI = "\<Esc>]50;CursorShape=1\x7"
"   let &t_EI = "\<Esc>]50;CursorShape=0\x7"
" endif

" if 0 ==  argc()
"   if getcwd() == "/Users/vitaly/my/config/dotvim2"
"     silent OpenTabSession vim2
"   endif
" endif


noremap             <plug>(Paste-Mode-Insert) :set paste<cr>o
nmap    <leader>i   <plug>(Paste-Mode-Insert)


" highlight column after textwidth
set cc=+1

" nunmap <leader>t
" nmap <leader>t :Tags<cr>


let g:ycm_filepath_completion_use_working_dir = 1

nmap ,Q :qa<cr>

set virtualedit=all

let g:session_autosave = 'no'
let g:session_autoload = 'no'

nmap <leader>H :Helptags<cr>

let g:syntastic_always_populate_loc_list = 1
let g:syntastic_javascript_checkers = ['eslint']

let g:gutentags_project_root = [ '.notags', '.ctags.d', 'tags' ]
" GutentagsToggleTrace

" set mouse=nvc

" inoremap <expr><tab> pumvisible() ? "\<c-n>" : "\<tab>"

" inoremap <expr><tab> pumvisible() ? "\<c-y>" : "\<tab>"

" inoremap <expr><c-j> pumvisible() ? "\<down>" : "\<c-j>"
" inoremap <expr><c-k> pumvisible() ? "\<up>" : "\<c-k>"




let g:over#command_line#search#enable_move_cursor = 1







"inoremap <expr> j ((pumvisible())?("\<C-n>"):("j"))





nmap <leader>bm :messages<cr>
nmap <leader>bM :messages clear<cr>






set diffopt-=internal
function! s:checkDiffModeEnter()
  if &diff && ! exists('b:diffMode')
    let b:diffMode=1
    doautocmd User DiffModeEnter
  endif
endfunction

function! s:checkDiffModeLeave()
  if ! &diff && exists('b:diffMode')
    unlet b:diffMode
    doautocmd User DiffModeLeave
  endif
endfunction

function! s:onDiffModeEnter()
  nmap <buffer> <localleader>du :diffupdate<CR>
  nmap <buffer> <localleader>dp :diffput<CR>
  nmap <buffer> <localleader>dg :diffget<CR>
  nmap <buffer> <localleader>n ]c
  nmap <buffer> <localleader>p [c
endfunction

function! s:onDiffModeLeave()
  nunmap <buffer> <localleader>du
  nunmap <buffer> <localleader>dp
  nunmap <buffer> <localleader>dg
  nunmap <buffer> <localleader>n
  nunmap <buffer> <localleader>p
endfunction

augroup diffbindings
  au!
  au FilterWritePre          * call s:checkDiffModeEnter()
  au FilterWritePre,BufWrite * call s:checkDiffModeLeave()

  au User DiffModeEnter call s:onDiffModeEnter()
  au User DiffModeLeave call s:onDiffModeLeave()
augroup END






""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"" ORG MODE """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

let g:org_todo_keywords = [['TODO', 'NOW', 'NEXT', 'WAIT', '|', 'DONE', 'SKIP', 'CANCELED', 'ARCHIVED']]
let g:org_todo_keyword_faces = [
      \ ['WAIT', 'red'],
      \ ['NEXT', 'blue'],
      \ ['SKIP', 'yellow'],
      \ ['CANCELED', 'grey'],
      \]

" au FileType org nmap <buffer> <localleader>tn <Plug>OrgTodoForward
" au FileType org nmap <buffer> <localleader>tp <Plug>OrgTodoBackward

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

"let &errorformat ='%-C,%E  [%n] %#%f:%l: %.%#,%C%m,%Z%p^'
" set makeprg=make

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

let g:UltiSnipsSnippetsDir = "~/.vim/UltiSnips"

let g:SuperTabDefaultCompletionType = "context"

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"" NEOPLETE CONFIG """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

" let g:deoplete#keyword_patterns.q = '[.a-zA-Z_]\k*'


""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"" IndentLine Settings """""""""""""""""""""""""""""""""""""""""""""""""""""""""
" let g:indentLine_char = 'â”Š'
" let g:indentLine_char = '.'
" let g:indentLine_color_term = 30
" let g:indentLine_bgcolor_term = 10
" exe "IndentLinesToggle"
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

source ~/.vim/local/my/vimrc.preview

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" AirlineTheme light
" AirlineTheme cool
" AirlineTheme one

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

" au! CursorHold *.js nested exe "silent! ptag " . expand("<cword>")
" au! CursorHold *.js nested call LanguageClient#textDocument_hover()

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" let g:neoformat_enabled_typescript = ['prettier']
" let g:neoformat_enabled_typescryptreact = ['prettier']

" let g:neoformat_verbose = 1
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
func! MotionJoinOperator(submode)
  '[,']join
endfunc
nnoremap gj :set operatorfunc=MotionJoinOperator<CR>g@

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
nnoremap <C-j> :m .+1<CR>==
nnoremap <C-k> :m .-2<CR>==
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
xnoremap <C-j> :m '>+1<CR>gv=gv
xnoremap <C-k> :m '<-2<CR>gv=gv
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" cnoreabbrev h vert bo h
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
let g:is_bash = 1
nmap <silent><esc> :silent noh<cr>
set ic

let g:taskwiki_sort_order = "pri-"

if !argc() && filereadable('.session.vim')
  echo "loading session"
  so ./.session.vim
endif

" set diffopt+=iwhiteall

" let g:neoformat_verbose = 1


let g:which_key_use_floating_win = 0
let g:which_key_align_by_seperator = 1


let g:EditorConfig_max_line_indicator = 'line'

command! LogOn set verbosefile=./vim.log | set verbose=9
command! LogOff set verbose=0 | set verbosefile=

fu! Toggle_verbose_log() abort
  if 0 == &verbose
    LogOn
    echom "Log to " . &verbosefile
  else
    LogOff
    echom "Log disabled"
  endif
endf

noremap <silent>                       <plug>(Toggle/Verbose-Log) :call Toggle_verbose_log()<CR>
nmap    <leader>Tv                     <plug>(Toggle/Verbose-Log)




" Tell vim to remember certain things when we exit
" !     :  remember ALL_CAPS_VARIABLES
"  '100 :  marks will be remembered for up to 10 previously edited files
"  <500 :  upto 50 lines saved per register
"  "100 :  will save up to 100 lines for each register
"  s100 :  saves upto 100K per item
"  h    :  disable hlsearch on load
"  %    :  saves and restores the buffer list
" set shada=!,'100,<500,s100,h
let g:ale_popup_menu_enabled = 1
" let g:ale_cursor_detail = 1
let g:ale_echo_cursor = 1
" echo g:ale_cursor_detail
" echo g:ale_echo_cursor
" echo g:ale_set_balloons
nmap     <leader>fed            <plug>(File/Edit/Local/After)

call my#keymap#leader('fez', '+Zsh')
noremap                         <plug>(File/Edit/Zsh/Host)              :e ~/.zsh/modules/local//host/<c-r>=get(environ(), 'PLEASE_HOST', trim(system('hostname -s')))<cr>.zsh<cr>
nmap     <leader>fezh           <plug>(File/Edit/Zsh/Host)


nmap     <leader>,                <Plug>(File/Toggle/File-Tree)
nmap     <localleader><leader>    <plug>(File/Save)
nmap     <leader>ww               <plug>(File/Save)


set noequalalways
nnoremap        <plug>(Toggle/Equal-Windows)    :<set equalalways!<CR>
nmap            <leader>TQ                      <plug>(Toggle/Equal-Windows)


fu! BrowseWithNerdTree()
  noremap <silent>  <plug>(Toggle/File-Tree)          :<C-U>NERDTreeTabsToggle<CR>
  noremap <silent>  <plug>(Tree-Find-File)            :<C-U>NERDTreeFind<CR>
endfu
nnoremap  <silent>  <plug>(Toggle/Filer/NerdTree)     :call BrowseWithNerdTree()<CR>

fu! BrowseWithDefx()
  nmap              <plug>(Toggle/File-Tree)          <plug>(Defx/Toggle)
  nmap              <plug>(Tree-Find-File)            <plug>(Defx/Find-File)
endfu
nnoremap  <silent>  <plug>(Toggle/Filer/Defx)         :call BrowseWithDefx()<CR>

fu! BrowseWithLuaTree()
  nmap              <plug>(Toggle/File-Tree)          <plug>(LuaTree/Toggle)
  nmap              <plug>(Tree-Find-File)            <plug>(LuaTree/Find-File)
endfu
nnoremap  <silent>  <plug>(Toggle/Filer/LuaTree)      :call BrowseWithLuaTree()<CR>

call my#keymap#leader('TF', '+Filer')
nmap                <leader>TFN                       <plug>(Toggle/Filer/NerdTree)
nmap                <leader>TFD                       <plug>(Toggle/Filer/Defx)
nmap                <leader>TFL                       <plug>(Toggle/Filer/LuaTree)

call BrowseWithNerdTree()
" call BrowseWithDefx()
" call BrowseWithLuaTree()

let g:ruby_indent_hanging_elements = 0



function! s:railsMoveToCanonicPath()
  let n = line('.')

  let output = system("ruby ~/.vim/local/ruby/rails/canonic-path.rb '" . expand('%') . "' " . n)

  echo output

  echo 'ok'
endfunction

command! RMoveToCanonicPath call s:railsMoveToCanonicPath()

call my#keymap#localleader('Rm',  '+Move')
nnoremap <silent> <localleader>Rmc  :RMoveToCanonicPath<CR>

" nnoremap <silent> <localleader>A :Neoformat<CR>
nmap <silent> <localleader>A :!rubocop -A %<CR>

command! Rubo !rubocop -A %







function! s:MoveSelection(line1, line2, target)
  " go to line `line1`
  exe 'normal! ' . a:line1  . 'G0'

  " echo 'starting at line ' . a:line1

  " echo 'target: ' . a:target
  " echo 'isdir: ' . isdirectory(a:target)

  let path = a:target

  if isdirectory(path)
    if path[len(path) - 1] != '/'
      let path .= '/'
    end
    " echo 'first line: ' . getline('.')
    let entity = substitute(getline('.'), '\v\s*(module|class)\s+(\w+).*$', '\2', '')
    " echo 'entity: ' . entity
    echom entity

    let filename = system("ruby -r active_support/core_ext/string -e 'puts \"" . entity .  ".rb\".underscore'")
    " echo 'path: ' . filename
    let path .= trim(filename)
  end

  echom path

  if path == expand('%')
    echo "SAME PATH"
    return
  endif

  " echo 'path: ' . path
  " echo 'isdir: ' . isdirectory(path)

  " search from the end of the file, so that it wraps to beginning
  silent exe '$/\v\s*module\s+'

  " echom 'after search at line ' . line('.')

  let l:n  = -1
  let l:count = 0

  if a:line1 > 1
    while line('.') > l:n && line('.') < a:line1
      let l:n  = line('.')
      " echom 'found ' l:n . ': ' . getline('.')

      if l:count == 0
        silent exe '.write! ' . path
      else
        silent exe '.write! >>' . path
      endif

      let l:count += 1

      silent normal! n
    endwhile
  endif

  " echom 'done'

  " copy range into new file
  silent exe a:line1 ',' a:line2 'write! >>' path

  " delete the range from this file
  silent exe a:line1 ',' a:line2 'delete'
  silent write

  exe 'normal! ' . a:line1  . 'G'
  normal! zz

  silent exe 'edit ' path

  while l:count > 0
    " echom 'count=' . l:count
    normal! Goend
    let l:count -= 1
  endwhile

  silent Autoformat
  write
endfunction

:command!   -bar -range -nargs=1 -complete=file      MoveSelection       call s:MoveSelection(<line1>, <line2>, '<args>')

map                    <plug>(Refactoring/Extract-Selection)   :MoveSelection %%
vmap  <localleader>re  <plug>(Refactoring/Extract-Selection)

nmap  <localleader>re  ^V%:MoveSelection %%<cr>

" nmap  <localleader>re  <plug>(Refactoring/Extract-Selection)
" map                    <plug>(Refactoring/Extract-Selection)   :10,22MoveSelection ./bar.rb<cr>
" map                    <plug>(Refactoring/Extract-Selection)   :3,5MoveSelection ./bar.rb<cr>
" <line1>,<line2>write<bang> <args> | <line1>,<line2>delete | write | edit <args> | RWrapModule | silent Neoformat | silent write
"
" let g:wrap_module_name = get(g:, 'wrap_module_name', 'Fb')
" function! s:RWrapModule()
"   exe "normal! ggOmodule ". g:wrap_module_name . "\<Esc>"
"   exe "normal! Goend\<Esc>gg"
" endfunction

" command! -bar RWrapModule call s:RWrapModule()

" :command! -bar -range -nargs=1 -complete=file MoveSelection  <line1>,<line2>write<bang> <args> | <line1>,<line2>delete | write | edit <args> | RWrapModule | silent Neoformat | silent write

if has('nvim') || has('terminal')
  aug set_typescript_repl
    au!
    au FileType typescript
          \ if executable('node_modules/.bin/ts-node')            |
          \   call neoterm#repl#set('node_modules/.bin/ts-node')  |
          \ elseif executable('ts-node')                          |
          \   call neoterm#repl#set('ts-node')                    |
          \ endif
  augroup END
end

set modelines=2



fu! DumpVars(match) abort
  for l:v in sort(filter(keys(g:), 'v:val =~ "' . a:match . '"'))
    echon 'g:' . l:v . ' = '
    echon get(g:, l:v)
    echo ''
  endfor

  for l:v in sort(filter(keys(b:), 'v:val =~ "' . a:match . '"'))
    echon 'b:' . l:v . ' = '
    echon get(b:, l:v)
    echo ''
  endfor
endfu
command! -nargs=1 DumpVars call DumpVars('<args>')

let g:tagbar_position='topleft vertical'


if g:dotvim#autoformat == 'vim-autoformat'

  let g:formatdef_rubocop = substitute(g:formatdef_rubocop, 'rubocop', 'binx rubocop', '')
  let g:formatters_ruby = ['rubocop']

  let g:formatdef_tsfmt = substitute(g:formatdef_tsfmt, 'tsfmt', 'npx typescript-formatter', '')
  let g:formatdef_prettier = substitute(g:formatdef_prettier, 'prettier', 'npx prettier', '')
  let g:formatters_jsonc = ["prettier"]
  let g:formatters_json = ["prettier"]
  let g:formatters_javascript = ["prettier"]
  let g:formatters_javascriptreact = ["prettier"]
  let g:formatters_typescript = ["prettier"]
  let g:formatters_typescriptreact = ["prettier"]

endif

source ~/.vim/local/after.lua
